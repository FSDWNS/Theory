#                        数据库系统

#### 一、并发特性

##### 1.事物特性

+ ###### 原子性：　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

+ ###### 一致性：　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

+ ###### 隔离性：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

+ ###### 持续性：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，
即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。

##### 2.并发产生的问题：

+ ###### 丢失更新：当两个或多个事务选择了同一行然后基于最初选定的值更新改行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新的问题，最后更新覆盖了由其他事务所做的更新。

+ ###### 不可重复读：事务T1读入某一数据后（未进行操作），T2对同一数据进行了操作（修改、插入、删除），当T1**再次读入**该数据时，得到与前一次不同的值（或者多了、少了某些记录）。这种不一致性与丢失修改的理想情况相反。

+ ###### 读“脏”数据：一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致的状态；这时，另一个事务也读取同一条基础，如果不加控制，第二个事务读取这些"脏"数据，并据此作进一步的处理，就会产生未提交的数据的依赖关系，这种叫做"脏读"

##### 3.解决方案（封锁协议）

###### S封锁：所谓S锁,是事务T对数据A加上S锁时,其他事务只能再对数据A加S锁,而不能加X锁,直到T释放A上的S锁。

###### X封锁：所谓X锁,是事务T对数据A加上X锁时,只允许事务T读取和修改数据A。

###### 若事务T对数据对象A加了S锁,则T就可以对A进行读取,但不能进行更新(S锁因此又称为读锁),在T释放A上的S锁以前,其他事务可以再对A加S锁,但不能加X锁,从而可以读取A,但不能更新A.

###### 两段锁协议：



```
1）一级封锁协议：
定义：事务T在修改数据A前，必须先对A加X锁，直到事务结束才释放。因此X锁又被称为写锁，意为修改。

目的：解决“丢失修改”的不一致问题，即在下一个事务操作前，先把上一个事务的修改操作结束。

实现：事务T1的X锁→事务T2的X锁

事务T1对数据对象A加上X锁后，只有等事务T1（修改）结束，释放X锁，事务T2才能对A加锁并进行操作（\读取、修改\）。

2）二级封锁协议：

定义：在一级封锁协议的基础上，增加事务T在读取数据A前，必须先对A加S锁，读完后即可释放。因此S锁又被称为读锁，意为读取。

目的：在一级封锁协议的基础上，进一步解决“读‘脏’数据”的不一致问题，即在下一个事务读取前，先等上一个事务的撤销操作结束。

实现：事务T1的X锁→事务T2的S锁（读取数据后释放S锁）

事务T1对数据对象A加上X锁后，只有等事务T1（修改、撤销）结束，释放X锁，事务T2才能对A加锁并进行操作（读取）。


3）三级封锁协议：

定义：在一级封锁协议的基础上，增加事务T在读取数据A前，必须先对A加S锁，直到事务结束才释放（与二级的区别）。

目的：在二级封锁协议的基础上，进一步解决“\不可重复读\”的不一致问题，即在下一个事务修改前，先等上一个事务的重复读操作结束。

实现：事务T1的S锁（事务结束后释放S锁）→事务T2的X锁

事务T1对数据对象A加上S锁后，只有等事务T1（重复读取）结束，释放S锁，事务T2才能对A加X锁并进行操作（修改）。
```

#### 二、SQL语言

##### 1.建表

```
create table person(
pid int PRIMARY KEY AUTO_INCREMENT,
pname varchar(30),
birthday datetime,
sex varchar(2),
phone varchar(16)
)
```

##### 2.删除表

```
DROP TABLE IF EXISTS `tordermain`;
```

##### 3.插入一条数据

```
insert into person(pname,birthday,sex,phone)values("1","2020-2-1","男","18295442564")
```

##### 4.删除一条数据

```
delete from person where id=1;
```

##### 5.查询数据

```
select*from person;//查询整张表
select birthday,sex,phone//查询某些字段
select distinct birthday from person;//去掉重复的数据
select *from person limit 1;//根据id查询指定的行数
select *from peron order by birthday desc；//根据生日的时间排序
```

##### 6.修改数据

```
update person set birthday="2021-1-1";
```

#### 三、规范化理论

##### 概念

##### 1.函数依赖

+ ###### 部分函数依赖

######  通过{学生学号，课程号}可以得到{该生姓名}，而通过单独的{学生学号}已经能够得到{该生姓名}，则说明{该生姓名}部分依赖于{学生学号，课程号}； 又比如， 通过{学生学号，课程号}可以得到{课程名称}，而通过单独的{课程号}已经能够得到{课程名称}，则说明{课程名称}部分依赖于{学生学号，课程号}。（部分依赖会造成数据冗余及各种异常。）

+ ###### 传递函数依赖

###### 在关系R（学号，宿舍，费用）中，通过{学号}可以得到{宿舍}，通过{宿舍}可以得到{费用}，而反之都不成立，则存在传递依赖{学号}->{费用}。（传递依赖也会造成数据冗余及各种异常。）

+ ###### 完全依赖

###### 通过{学生学号， 选修课程名}可以得到{该生本门选修课程的成绩}，而通过单独的{学生学号}或者单独的{选修课程名}都无法得到该成绩，则说明{该生本门选修课程的成绩}完全依赖于{学生学号，选修课程名}

##### 2.候选键

###### 要了解候选键，首先先了解超键。

##### 超键：在关系模式中，能唯一标识元组的属性集称为超键。

##### 候选键 :如果一个属性集能唯一标识元组，且有不包含多余属性，那么这个属性集称为候选键；也即：候选键是没有多余属性的超键。

##### 同理可得，那么超键可以看作是带有其他有多余属性的候选键，也即候选键带上任意个其他属性可被视为超键。

Example;

```
1.（假设姓名无重复）
姓名，学号，年龄
a,1,20
b,2,30
c,3,23
姓名唯一，是个超键
学号唯一，是个超键
（姓名，年龄）唯一 ，是个超键
（学号，努力）唯一，是个超键
姓名唯一，且没有其他多余属性，是个候选键
学号唯一，且没有其他多余属性，是个候选键
```



###### 主键： 主键就是候选键里面的一个，是人为规定的，例如学生表中，我们通常会让“学号”做主键，学号能唯一标识这一个元组。

###### 外键：假如我们还有一个教师表，每个教师都有自己的编号，假设老师编号在老师这个层次中是主键，在学生表中它就是外键。

###### 主属性：在一个关系中，如一个属性是构成某一个候选关键字的属性集中的专一个属性，则属称它为主属性。

###### 非主属性：不包含在任何一个候选码中的属性称为非主属性。非主属性是相对与主属性来定义的，是指关系中不包含任何一个候选码中的属性。

#### 四、价值和用途

###### 1.消除数据冗余



###### 2.消除修改异常



###### 3.消除插入异常



###### 4.消除删除异常



###### 5.范式



###### 6.模式分解

#### 五、关系代数

+ ###### 并

+ ###### 交

+ ###### 差

+ ###### 笛卡尔积

+ ###### 投影

##### 1.联接

###### 自然连接

###### 等值连接

